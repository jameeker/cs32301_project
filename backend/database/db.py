"""
db.py -- Database config and SQLAlchemy models for Flask app
Provides database connection, ORM models, and helper functions for database operations used throughout codebase
"""
import configparser
import os
from datetime import datetime, timedelta

# SQLAlchemy imports for database interaction
from sqlalchemy import text, func
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, Boolean, Float, ForeignKey, Enum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, sessionmaker, scoped_session

# Load database connection string from configuration file
config = configparser.ConfigParser()
ini_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'yoyo.ini')
config.read(ini_path)
DATABASE_URL = config['DEFAULT']['database']

# Create database engine with default connection parameters
# Production settings commented out below for reference
# engine = create_engine(
#     DATABASE_URL,
#     pool_pre_ping=True,  # Test connection before use to avoid stale connections
#     pool_recycle=3600,   # Recycle connections after 1 hour
#     pool_size=20,        # Increase from default 5
#     max_overflow=20,     # Increase from default 10
#     pool_timeout=60      # Increase timeout to 60 seconds
# )
engine = create_engine(DATABASE_URL)

# Create session factory for database interactions
session_factory = sessionmaker(bind=engine)
Session = scoped_session(session_factory)

# Base class for ORM models - all table classes inherit from this
Base = declarative_base()

#-----------------------------------------------------------------------------
# DATABASE MODELS
#-----------------------------------------------------------------------------

class User(Base):
    """User model representing application users.
    
    Stores user identifiers and preferences, with each user identified by a unique user_id.
    """
    __tablename__    = "Users"
    user_id          = Column(String(255), primary_key=True)
    session_token    = Column(String(255), unique=True, nullable=False)
    created_at       = Column(DateTime, default=datetime.utcnow, nullable=False)
    last_active      = Column(DateTime, default=datetime.utcnow, nullable=False)
    user_agent       = Column(String(255))
    ip_hash          = Column(String(64))
    theme_preference = Column(String(50), default="default")
    board_background = Column(String(255), default="default_corkboard.jpg")

class Note(Base):
    """Note model representing content posted to bulletin boards.
    
    Notes can be regular sticky notes or prompts, and have various attributes
    including content, color, position, and creator.
    """
    __tablename__     = "Notes"
    note_id           = Column(Integer, primary_key=True, autoincrement=True)
    content           = Column(Text, nullable=False)                         # The text content of the note
    color             = Column(String(20), default="yellow", nullable=False) # CSS color value
    format            = Column(String(20), default="text")                   # Format of the content (text, markdown, etc.)
    created_at        = Column(DateTime, default=datetime.utcnow, nullable=False)
    expires_at        = Column(DateTime, nullable=False)                     # When the note should expire (typically 24h after creation)
    type              = Column(Enum("sticky", "poster", name="note_type"), default="sticky", nullable=False)
    is_prompt         = Column(Boolean, default=False, nullable=False)       # Whether this note is a prompt for users
    prompt_id         = Column(Integer, ForeignKey("Notes.note_id", ondelete="SET NULL")) # Parent prompt if this is a response
    created_by        = Column(String(255), ForeignKey("Users.user_id", ondelete="CASCADE"), nullable=False)
    is_auto_generated = Column(Boolean, default=False, nullable=False)       # Whether this was auto-generated by the system
    
    # Relationships for easier ORM access
    creator = relationship("User", backref="notes")
    states = relationship("NoteState", backref="note", cascade="all, delete-orphan")
    
    # Helper method to create a note with default expiration of 24 hours
    @classmethod
    def create(cls, **kwargs):
        if 'expires_at' not in kwargs:
            kwargs['expires_at'] = datetime.utcnow() + timedelta(hours=24)
        return cls(**kwargs)

class NoteState(Base):
    """NoteState model representing the current state and position of a note.
    
    Each note can have multiple states (public, personal, trash, archived)
    allowing the same note to appear in different views for different users.
    """
    __tablename__ = "Note_States"
    state_id      = Column(Integer, primary_key=True, autoincrement=True)
    note_id       = Column(Integer, ForeignKey("Notes.note_id", ondelete="CASCADE"), nullable=False)
    # State values: public (on main board), personal (saved to user's board), trash, archived
    state         = Column(Enum("public", "personal", "trash", "archived", name="state_type"), nullable=False)
    user_id       = Column(String(255), ForeignKey("Users.user_id", ondelete="CASCADE"))
    # Position values are normalized 0-1 values (not pixels) for responsive layout
    position_x    = Column(Float, default=0.5)  # Horizontal position as fraction of board width
    position_y    = Column(Float, default=0.5)  # Vertical position as fraction of board height
    added_at      = Column(DateTime, default=datetime.utcnow, nullable=False)
    weather_level = Column(Integer, default=0, nullable=False)  # Visual effect intensity (unused)
    z_index       = Column(Integer, default=0)                  # For note stacking order
    rotation      = Column(Float, default=0)                    # Rotation angle in degrees
    
    # Relationship to access the user who owns this state
    user = relationship("User", backref="note_states")

#-----------------------------------------------------------------------------
# DATABASE ACCESS FUNCTIONS
#-----------------------------------------------------------------------------

def get_db():
    """Get a database session for performing operations.
    
    Returns:
        SQLAlchemy session object that will be automatically closed when done.
    """
    db = Session()
    try:
        return db
    finally:
        # Session will be closed when the request is completed
        db.close()

#-----------------------------------------------------------------------------
# CORE DATABASE OPERATIONS
#-----------------------------------------------------------------------------

def create_new_note(db, content, user_id, color="yellow", is_prompt=False, prompt_id=None, position_x=0.5, position_y=0.5):
    """Create a new note and add it to the public board.
    
    Args:
        db: Active database session
        content: Text content for the note
        user_id: ID of the user creating the note
        color: CSS color value for the note background
        is_prompt: Whether this note is a prompt
        prompt_id: ID of parent prompt if this is a response
        position_x: Horizontal position (0-1 range)
        position_y: Vertical position (0-1 range)
        
    Returns:
        Newly created Note object with ID assigned
    """
    # Create the note object using the helper method for expiration
    new_note = Note.create(
        content=content,
        color=color,
        created_by=user_id,
        is_prompt=is_prompt,
        prompt_id=prompt_id
    )
    
    # Add to database and get ID
    db.add(new_note)
    db.flush()  # Gets the ID without committing transaction
    
    # Create the public state for this note (visible on main board)
    public_state = NoteState(
        note_id=new_note.note_id,
        state="public",
        position_x=position_x,
        position_y=position_y
    )
    db.add(public_state)
    
    # Also update the user's last active timestamp
    user = db.query(User).filter(User.user_id == user_id).first()
    
    if user:
        # Update existing user's last activity time
        user.last_active = datetime.utcnow()
    else:
        # Create temporary user if they don't exist yet (for anonymous notes)
        new_user = User(
            user_id=user_id,
            session_token=f"temp-{datetime.utcnow().timestamp()}",
            user_agent="Anonymous",
            ip_hash="anonymous"
        )
        db.add(new_user)
    
    # Commit all changes
    db.commit()
    return new_note

def get_public_notes(db):
    """Get all active notes on the public board.
    
    Returns a list of (Note, NoteState) tuples for all notes that are:
    1. Currently in "public" state
    2. Not expired
    3. Ordered with prompts first, then by z-index, then by creation date
    
    Args:
        db: Active database session
        
    Returns:
        List of (Note, NoteState) tuples
    """
    return (db.query(Note, NoteState)
            .join(NoteState)  # Join the Notes and Note_States tables
            .filter(NoteState.state == "public")  # Only public notes
            .filter(Note.expires_at > datetime.utcnow())  # Not expired
            # Order: prompts first, then by z-index, then newest first
            .order_by(Note.is_prompt.desc(), NoteState.z_index.asc(), Note.created_at.desc())
            .all())

def save_note_to_personal(db, note_id, user_id, position_x=0.5, position_y=0.5):
    """Save a note from public board to user's personal board.
    
    Creates a "personal" state for an existing note, making it appear on the
    user's personal board without affecting the original note.
    
    Args:
        db: Active database session
        note_id: ID of the note to save
        user_id: ID of the user saving the note
        position_x: Horizontal position (0-1 range)
        position_y: Vertical position (0-1 range)
        
    Returns:
        Newly created NoteState object for the personal board
    """
    personal_state = NoteState(
        note_id=note_id,
        state="personal",
        user_id=user_id,
        position_x=position_x,
        position_y=position_y
    )
    db.add(personal_state)
    db.commit()
    return personal_state

def get_personal_notes(db, user_id):
    """Get all notes on a user's personal board.
    
    Args:
        db: Active database session
        user_id: ID of the user whose personal board to retrieve
        
    Returns:
        List of (Note, NoteState) tuples for notes on personal board
    """
    return (db.query(Note, NoteState)
            .join(NoteState)
            .filter(NoteState.state == "personal")
            .filter(NoteState.user_id == user_id)
            .order_by(Note.is_prompt.desc(), NoteState.z_index.asc())
            .all())

def get_trashed_notes(db, user_id):
    """Get all notes in a user's trash.
    
    Args:
        db: Active database session
        user_id: ID of the user whose trash to retrieve
        
    Returns:
        List of (Note, NoteState) tuples for trashed notes
    """
    return (db.query(Note, NoteState)
            .join(NoteState)
            .filter(NoteState.state == "trash")
            .filter(NoteState.user_id == user_id)
            .order_by(NoteState.added_at.desc())  # Most recently trashed first
            .all())

def move_note_to_trash(db, note_id, user_id):
    """Move a note from personal board to trash.
    
    Args:
        db: Active database session
        note_id: ID of the note to move to trash
        user_id: ID of the user moving the note
        
    Returns:
        Newly created NoteState object for the trash
    """
    # First, remove from personal board
    db.query(NoteState)\
      .filter(NoteState.note_id == note_id)\
      .filter(NoteState.user_id == user_id)\
      .filter(NoteState.state == "personal")\
      .delete()
    
    # Then add to trash
    trash_state = NoteState(
        note_id=note_id,
        state="trash",
        user_id=user_id
    )
    db.add(trash_state)
    db.commit()
    return trash_state

def remove_note(db, note_id, user_id=None):
    """Remove a note from the database.
    
    Args:
        db: Active database session
        note_id: The ID of the note to delete
        user_id: Optional. If provided, verify the user is the creator.
    
    Returns:
        True if deleted, False if not found or unauthorized
    """
    note = db.query(Note).filter(Note.note_id == note_id).first()
    
    if not note:
        return False  # Note does not exist
    
    if user_id and note.created_by != user_id:
        return False  # User is not the owner, deny delete
    
    # When the note is deleted, all associated NoteState entries
    # will be deleted automatically due to the cascade setting
    db.delete(note)   
    db.commit()
    return True

def modify_note(db, note_id, new_content, user_id=None):
    """Modify the content of a note.
    
    Args:
        db: Active database session
        note_id: The ID of the note to update
        new_content: New text content for the note
        user_id: Optional. If provided, only allow modification by the creator.
    
    Returns:
        True if modified, False if not found or unauthorized
    """
    note = db.query(Note).filter(Note.note_id == note_id).first()
    
    if not note:
        return False  # Note not found
    
    if user_id and note.created_by != user_id:
        return False  # User is not the owner, deny edit

    note.content = new_content
    db.commit()
    return True

def filter_notes(
    db,
    user_id=None,
    text_contains=None,
    color=None,
    created_after=None,
    created_before=None,
    within_bounds=None  # Tuple: (x_min, x_max, y_min, y_max)
):
    """Search for notes with various filters.
    
    Args:
        db: Active database session
        user_id: Filter by note creator
        text_contains: Filter by text content (case insensitive)
        color: Filter by note color
        created_after: Filter by creation date (after this datetime)
        created_before: Filter by creation date (before this datetime)
        within_bounds: Filter by position (tuple of x_min, x_max, y_min, y_max)
        
    Returns:
        List of Note objects matching the criteria
    """
    query = db.query(Note)
    
    # Apply filters conditionally based on provided parameters
    if user_id:
        query = query.filter(Note.created_by == user_id)
    
    if text_contains:
        query = query.filter(Note.content.ilike(f"%{text_contains}%"))
    
    if color:
        query = query.filter(Note.color == color)
    
    if created_after:
        query = query.filter(Note.created_at >= created_after)
    
    if created_before:
        query = query.filter(Note.created_at <= created_before)

    if within_bounds:
        x_min, x_max, y_min, y_max = within_bounds
        # Join with NoteState to filter by position
        query = query.join(NoteState).filter(
            NoteState.position_x >= x_min,
            NoteState.position_x <= x_max,
            NoteState.position_y >= y_min,
            NoteState.position_y <= y_max
        )

    return query.all()

#-----------------------------------------------------------------------------
# DATABASE TESTING AND DEBUGGING FUNCTIONS
#-----------------------------------------------------------------------------

def show_tables(db, include_yoyo=False, only_app_tables=True):
    """Show tables that exist in the database.
    
    Useful for verifying database structure and migrations.
    
    Args:
        db: Database session
        include_yoyo: If False, filter out Yoyo migration tables
        only_app_tables: If True, only show application tables (Users, Notes, Note_States)
    
    Returns:
        List of table names
    """
    result = db.execute(text("SHOW TABLES"))
    all_tables = [row[0] for row in result]
    
    # Filter tables based on parameters
    if not include_yoyo:
        # Filter out any table with 'yoyo' in the name
        all_tables = [table for table in all_tables if 'yoyo' not in table.lower()]
    
    if only_app_tables:
        # Only include application tables
        app_tables = ['users', 'notes', 'note_states'] 
        all_tables = [table for table in all_tables if table.lower() in app_tables]
    
    return all_tables

def count_all_notes(db):
    """Return the total number of notes in the database."""
    return db.query(Note).count()

def count_notes_by_state(db):
    """Return a count of notes in each state (public, personal, trash, archived)."""
    results = db.query(NoteState.state, 
                     func.count(NoteState.note_id))\
              .group_by(NoteState.state)\
              .all()
    return dict(results)

def get_recent_notes(db, limit=10):
    """Get recently created notes."""
    return db.query(Note)\
           .order_by(Note.created_at.desc())\
           .limit(limit)\
           .all()

def get_user_stats(db):
    """Get statistics about users and their notes.
    
    Returns a dictionary with user count, notes per user, and average notes per user.
    """
    # Count total users
    user_count = db.query(User).count()
    
    # Count notes created by each user
    notes_per_user = db.query(
        Note.created_by,
        func.count(Note.note_id)
    ).group_by(Note.created_by).all()
    
    # Calculate average notes per user
    if user_count > 0:
        total_notes = sum(count for _, count in notes_per_user)
        avg_notes = total_notes / user_count
    else:
        avg_notes = 0
    
    return {
        "user_count": user_count,
        "notes_per_user": dict(notes_per_user),
        "average_notes_per_user": avg_notes
    }

def dump_table_data(db, model_class):
    """Return all rows from a table as dictionaries.
    
    Useful for debugging and data export.
    
    Example: dump_table_data(db, User)
    """
    items = db.query(model_class).all()
    
    # Convert SQLAlchemy objects to plain dictionaries
    result = []
    for item in items:
        item_dict = {}
        for column in model_class.__table__.columns:
            column_name = column.name
            column_value = getattr(item, column_name)
            item_dict[column_name] = column_value
        result.append(item_dict)
    
    return result

def show_table_schema(db, table_name):
    """Display column information for a specific table.
    
    Useful for verifying table structure matches expected schema.
    """
    result = db.execute(text(f"DESCRIBE `{table_name}`"))
    columns = []
    for row in result:
        columns.append({
            'field': row[0],
            'type': row[1],
            'null': row[2],
            'key': row[3],
            'default': row[4],
            'extra': row[5]
        })
    return columns

def check_foreign_keys(db):
    """Verify foreign key relationships are properly set up.
    
    Returns information about all foreign key constraints in the database.
    """
    result = db.execute(text("""
        SELECT 
            TABLE_NAME, COLUMN_NAME, 
            REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
        FROM information_schema.KEY_COLUMN_USAGE
        WHERE REFERENCED_TABLE_SCHEMA = DATABASE()
          AND REFERENCED_TABLE_NAME IS NOT NULL
    """))
    
    fk_relationships = []
    for row in result:
        fk_relationships.append({
            'table': row[0],
            'column': row[1],
            'references_table': row[2],
            'references_column': row[3]
        })
    return fk_relationships

def get_db_size(db):
    """Get the total size of the database and individual tables.
    
    Returns a dictionary with total size and size by table in MB.
    """
    result = db.execute(text("""
        SELECT 
            table_name,
            ROUND(((data_length + index_length) / 1024 / 1024), 2) AS size_mb
        FROM information_schema.TABLES
        WHERE table_schema = DATABASE()
        ORDER BY size_mb DESC
    """))
    
    sizes = {}
    total_size = 0
    for row in result:
        table_size = float(row[1])
        sizes[row[0]] = table_size
        total_size += table_size
    
    return {'total_mb': total_size, 'tables': sizes}
